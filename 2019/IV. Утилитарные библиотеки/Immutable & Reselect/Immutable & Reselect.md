Immutable & Reselect. Конспект лекций
=====================================

Цель и задачи лекции
--------------------

1. Познакомиться и получить общее представление об утилитарных библиотеках:

    - Immutable.js

    - Reselect

2. Получить практические навыки работы с библитеками

План лекции
-----------

1. Библиотека Immutable.js

    - Назначение библиотеки

    - Основные особенности

    - Типы данных, реализуемые библиотекой

    - ленивые последовательнсти

    - Применение в контексте Redux Store

2. Библиотека Reselect

    - Назначение библиотеки

    - Состав библиотеки

    - Кастомизация поведения

    - Основные приёмы работы

    - Применение в контексте Redux Store

Основная часть занятия
----------------------

+ На прошлом занятии мы рассмотрели одну из библиотек, реализующих некоторые элементы парадигмы функционального программирования -- библиотеку Lodash. Сегодня рассмотрим ещё одну, более строго реализующую принципы неизменности экземпляров данных и предоставляющую типы структур, полезные при реализации сложных алгоритмов

+ Данная библиотека разработана разработчиками команды Facebook и служит целям овышения эффективности и читаемости создаваемого программного кода

+ Основным свойством объектов, созданных с помощью функционала библиотеки является свойство неизменяемости экземпляров данных.

+ Методы, направленные на преобразование хранимых данных не изменяют данные внутри контейнера, вместо этого они генерируют новый экземпляр контейнера

+ Библиотека реализует следующие основные структуры данных:

    - `Map` -- ассоциативная карта

    - `List` -- список

    - `OrderedMap` -- комбинация карты и списка, гарантирующая порядок итерации данных ассоциативной карты

    - `Set` -- множество, абстракция работы со множествами

    - `OrderedSet` -- упорядоченное множество, аналогично `OrderedMap`

    - `Stack` -- стек, абстракция работы со стековыми структурами

    - `Record` -- фабрика объектовс предустановленными свойствами

+ В качестве отдельной структуры данных можно рассмотреть `Seq` -- ленивые последовательности

+ Следует помнить, любая `immutable`-коллекция, как `List`, `Map`, `Stack` или `Seq` может быть преобразована к ленивой последовательности

+ Использование ленивых последовательностей может существенно повысить производительность алгоритмов работы с большими объёмами данных

+ Рассмотрим пример работы с ленивыми последовательностями:

```js
import { Seq } from 'immutable'

const oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ])
    .filter(x => x % 2 !== 0)
    .map(x => x * x)

oddSquares.get(1) // 9
```

+ В рассмотренном примере функция `filter` будет вызвана три раза (для элементов 1, 2, 3), а функция `map` будет вызвана только один раз (для элемента с индексом "1" продуцированного массива [1, 3])

+ Свойство неизменности позволяет элегантно формировать редюсеры в парадигме `Redux Store`

+ использование JS-объектов:

```js
// using of native JS-objects
const defaultState = {
    data: 123,
    transformed: null
}

const reducerMap = {
    SOME_ACTION: (state, { data }) => ({
        ...state,
        data,
        transformed: transform(data)
    })
}

export default (state = defaultState, action) =>
    (_.invoke(reducerMap, action.type, state, action) || state)

```

+ использование Immutable объектов:

```js
// using of immutable objects
const defaultState = Map({
    data: 123,
    transformed: null
})

const reducerMap = {
    SOME_ACTION: (state, { data }) => state
        .set('data', data)
        .set('transformed', transform(data))
}

export default (state = defaultState, action) =>
    (_.invoke(reducerMap, action.type, state, action) || state)

```

+ Библиотека `reselect` разработана командой разработки Redux и предназначена главным образом для мемоизации результатов выборки данных из `Redux Store`

+ Мемоизация данных выборки позволяет существенно увеличить производительность программы за счёт сохранения результатов выборки, к которым возможно частое обращение в ходе работы программы

+ Основная функция, используемая из этой библиотеки -- `createSelector`, при вызове использует два параметра:

    - селектор или массив селекторов, применяемых каждый раз при вызове результирующего селектора

    - результирующая функция трансформации, применяемая единственный раз для уникального набора результатов селектора. Уникальность результатов по-умолчанию проверяется простым сравнением

+ В качестве результата работы функция `createSelector` возвращает селектор, который в свою очередь может быть использован как аргумент при дальнейшем создании селекторов

+ В случае необходимости дополнительных опций сравнения результатов, можно создать кастомный создатель селектора:

```js
import { isEqual } from 'lodash'
import { defaultMemoize, createSelectorCreator } from 'reselect'

const createDeepEqualSelector = createSelectorCreator(
    defaultMemoize,
    isEqual
)
```

+ такой селектор будет идентифицировать результат выполнения предыдущих селекторов по правилам `lodash.isEqual`

+ В парадигме `Redux Store` мы пожем определять селекторы данных как:

```js
import { get } from 'lodash/fp'
import { createSelector } from 'reselect'

const selector1 = get('sliceOne')
const selector2 = get('sliceTwo')

// for example only!
const someResult = (...args) => args

export const selectorX = createSelector([selector1, selector2],
    (result1, result2) => someResult(result1, result2))

export const selectorY = createSelector(selector1,
    result1 => someResult(result1))
```

Литература и ссылки
-------------------

1. [Документация по Immutable](https://immutable-js.github.io/immutable-js/docs/#/)

2. [Документация по Reselect](https://github.com/axios/axios)


Вопросы для самоконтроля
------------------------

1. Основное назначение библиотеки `Immutable`

2. В чём польза ленивых вычислений

3. В чём плюсы использования библиотеки `reselect` для выборки данных
